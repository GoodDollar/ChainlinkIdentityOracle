// SPDX-License-Identifier: MIT

pragma solidity >0.8.0;

import "hardhat/console.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol";

contract IdentityOracle is Ownable {
    address public dao_avatar; // this implementation is only to test. In live it would be replaced for dao.avatar

    bytes32 public stateHash = 0x0e8d3a960d058403c71b98a920e76d23683589ded04b08d877f3da31dcca18c6; // current state hash
    string  public stateDataIPFS = 'bafkreibpjfb52jogprvsjydbyncqbazpcd376r46x6znlzknhzkqkb5pba'; // ipfs cid

    address public CHAINLINK_NODE_ADDRESS =
        0x8CC93F854df3d9815331Cd178f496d4Db1D677A3;

    uint256 public lastStartUpdProcInvoked;

    struct WhitelistProofState {
        uint256 lastProofDate;
        uint256 lastAuthenticatedDate;
    }

    mapping(address => WhitelistProofState) private whitelistProofState;
    event ProofResult(bool);
    mapping(address => bool) private oracleState; // Store oracle address ad if isAllowed

    constructor(address _link) Ownable() {
        dao_avatar = msg.sender;
        oracleState[CHAINLINK_NODE_ADDRESS] = true;
        oracleState[msg.sender] = true;
    }

    function _onlyOracle() internal view {
        require(
            oracleState[msg.sender],
            "only allowed oracle can call this method"
        );
    }

    function _onlyAvatar() internal view {
        require(
            address(dao_avatar) == msg.sender,
            "only avatar can call this method"
        );
    }

    //- only the DAO can approve/remove an oracle. onlyAvatar is defined in DAOUpgradeableContract
    function setOracle(address _oracle, bool _isAllowed) public {
        _onlyAvatar();
        oracleState[_oracle] = _isAllowed;
    }

    // It's the second function to be called by the oracle to store the StateHash value and IPFSCID
    function setFulfillStateHashIPFSCID(bytes memory _statehashipfscid)
        public
    // This function is called only oracle
    //- only approved oracles can set the new merkle state plus link to ipfs data used to create state
    {
        _onlyOracle();
        (bytes32 _statehash, string memory _ipfscid) = abi.decode(_statehashipfscid,(bytes32,string));
        stateHash = _statehash;
        stateDataIPFS = _ipfscid;
    }

    //- prove that pair publicAddress, lastAuthenticated exists in current state.
    //update address state in smart contract. also update address lastProofDate (required by isWhitelisted below).
    //Proof can be generated by "sdk" defined in previous step.
    function prove(
        address _address,
        uint256 _lastAuthenticated,
        bytes32[] memory _proof
    ) public {
        bool result = false;
        (, result) = _checkMerkleProof(
            _address,
            _lastAuthenticated,
            stateHash,
            _proof
        );
        //update address state in smart contract. also update address lastProofDate (required by isWhitelisted below).
        if (result) {
            WhitelistProofState memory state;
            state.lastProofDate = block.timestamp;
            state.lastAuthenticatedDate = _lastAuthenticated;
            whitelistProofState[_address] = state;
        }
        emit ProofResult(result);
    }

    function _checkMerkleProof(
        address _address,
        uint256 _lastAuthenticated,
        bytes32 _root,
        bytes32[] memory _proof
    ) internal pure returns (bytes32 leafHash, bool isProofValid) {
        leafHash = keccak256(abi.encode(_address, _lastAuthenticated));
        isProofValid = MerkleProofUpgradeable.verify(_proof, _root, leafHash);
    }

    //- returns true if address is whitelisted under maxProofAge and maxAuthentication age restrictions.
    //maxProofAge should be compared to lastProofDate and maxAuthenticationAge to lastAuthenticated.
    //if 0 is supplied then they are ignored.
    function isWhitelisted(
        address _address,
        uint256 _maxProofAgeInDays,
        uint256 _maxAuthenticationAgeInDays
    ) public view returns (bool) {
        bool result = false;
        WhitelistProofState memory state = whitelistProofState[_address];
        if (state.lastProofDate > 0) {
            if (
                (_maxAuthenticationAgeInDays == 0 ||
                    state.lastAuthenticatedDate >
                    block.timestamp - _maxAuthenticationAgeInDays * 1 days) &&
                (_maxProofAgeInDays == 0 ||
                    state.lastProofDate >
                    block.timestamp - _maxProofAgeInDays * 1 days)
            ) {
                result = true;
            }
        }
        return result;
    }
  
    function setCLNodeAdderss(address _clnodeaddress) public {
        _onlyAvatar();
        CHAINLINK_NODE_ADDRESS = _clnodeaddress;
    }

}
